%Doc-1.0
\documentstyle{manual}

%Doc-1.0
%counter{chapter}[arabic] = 1
%label{glyph}{2.1}
%label{req}{?}
%label{allot}{2.4}
%label{char}{2.5}
%label{glue}{2.7}
%label{layout}{2.8}
%label{box}{2.9}
%label{deck}{2.10}
%label{page}{2.11}
%label{monoglyph}{2.12}
%label{background}{2.13}
%label{margin}{2.14}
%label{shadow}{2.15}
%label{markers}{2.16}
%label{tformsetter}{2.17}
%label{center}{2.18}
%label{composition}{2.19}
%label{compositor}{2.20}
%label{patch}{2.21}
%label{rule}{2.6}
%label{hit}{2.2}
%label{requisition}{2.3}

\begin{document}
%
%
\chapter{Glyphs}%
%
\float{figure}{2-\pagenumber{00}}%372.72 -645.84 0
A glyph is an object that draws.  Glyphs are the basic building blocks
for the presentation side of a user interface.  Glyphs define no storage
by default and are passed  contextual information during rendering.
Thus, glyphs may be shared and a glyph structure need not be strictly
hierarchical; it may be a directed acyclic graph.

\quad There are three kinds of glyph subclasses.  {\it Primitive}
glyphs are leaves--they contain no components.  {\it Composite} glyphs
contain several components and typically arrange them in some form.  {\it Monoglyphs}  contain
a single component, and they alter the component's appearance or behavior.
%
%
\section{Glyph base class}%
%
Glyph is a subclass of resource because glyphs can be shared. Resource
must be a virtual base class to ensure that only one copy of resource
information (i.e., reference count) is managed in the case of multiple
inheritance.  Figure \ref{glyph} shows the glyph base class definition.%
%
\code{typedef long GlyphIndex;\
typedef unsigned int GlyphBreakType;\
\
class Glyph : virtual public Resource \{\
protected:\
\quad Glyph();\
public:\
\quad virtual void request(Requisition\&) const;\
\quad virtual void allocate(Canvas*, const Allocation\&, Extension\&);\
\quad virtual void draw(Canvas*, const Allocation\&) const;\
\quad virtual void print(Printer*, const Allocation\&) const;\
\quad virtual void pick(Canvas*, const Allocation\&, int depth, Hit\&);\
\
\quad enum \{ no\_break, pre\_break, in\_break, post\_break \};\
\quad virtual Glyph* compose(GlyphBreakType) const;\
\
\quad virtual void append(Glyph*);\
\quad virtual void prepend(Glyph*);\
\quad virtual void insert(Glyph*);\
\quad virtual void remove(Glyph*);\
\quad virtual void replace(GlyphIndex, Glyph*);\
\quad virtual void change(GlyphIndext);\
\quad virtual GlyphIndex  count() const;\
\quad virtual Glyph* component(GlyphIndex) const;\
\quad virtual void allotment(\
\quad \quad GlyphIndext, DimensionName, Allotment\&\
\quad ) const;\
\}; %
%
\figurecaption{Glyph class interface\label{glyph}}%
%
%-4.57764e-05 6.71997 1
}%
%
%
%
\subsection{Geometry management}%
%
Glyph::request asks a glyph to specify its desired geometry in the
given requisition.  It is desirable that this operation be fast so
that a composite glyph need not store the requistions for its components.  Glyph::allocate
notifies a glyph that a portion of the canvas has been allocated for
it.  A glyph can assume that allocate will be called before draw is
called with the same canvas and allocation. %
%
\subsection{Drawing}%
%
\float{figure}{2-\pagenumber{00}}%372.24 -644.96 -2
Glyph::draw displays the glyph on the canvas at the position and size
specified by the allocation.  No clipping or translation is implicit
in this operation--the canvas is the entire drawing area and the allocation
is in canvas coordinates.  However, a composite glyph may set clipping
on the canvas before drawing its children.

\quad There is no guarantee that a call to draw will affect the screen
immediately because of the possibility (indeed, likelihood) that the
canvas is double-buffered.  Furthermore, drawing order is important
for glyphs when they are partially transparent and are drawn in the
same plane.  A glyph's draw operation therefore should not be called
directly, but rather is implicitly called during screen update.

\quad Glyph::print generates a representation of the glyph graph suitable
for printing.  The canvas and printer rendering interfaces are identical,
and the default implementation of print is simply to call draw.  Most
glyphs therefore need not define a print operation.  The reason for
a distinct print operation is to allow a glyph to use different rendering
requests for the screen and a printer.  For example, a glyph might
use 3D requests to the screen, or might compute more precise output
for printing.

\quad Glyph::pick finds the glyphs that intersect a point or rectangle
specified in canvas-relative coordinates. Conceptually, picking is
like drawing and determining what glyphs intersect the specified point
or rectangle.  The coordinates are contained in the hit parameter.  The
depth parameter specifies which level in the Hit object to store the  intersecting
glyphs.  When pick returns, the Hit parameter contains the glyphs
that were hit.

\quad Figure%
%
\code{class Hit \{\
public:\
\quad Hit(const Event*);\
\quad Hit(Coord x, Coord y);\
\quad Hit(Coord left, Coord bottom, Coord right, Coord top);\smallskip
\quad virtual const Event* event() const;\
\quad virtual Coord left() const;\
\quad virtual Coord bottom() const;\
\quad virtual Coord right() const;\
\quad virtual Coord top() const;\smallskip
\quad virtual vod push\_transform();\
\quad virtual void transform(const Transformer\&);\
\quad virtual void pop\_transform();\smallskip
\quad virtual void begin(int depth, Glyph*, GlyphIndex, Handler* =
nil);\
\quad virtual void target(int depth, Glyph*, GlyphIndex, Handler*
= nil);\
\quad virtual void end();\
\quad virtual void remove(int depth, GlyphIndex target = 0);\
\quad virtual void retarget(\
\quad \quad int depth, Glyph*, GlyphIndex, Handler* = nil, GlyphIndex
= 0\
\quad );\smallskip
\quad virtual boolean any() const;\
\quad virtual int count() const;\
\quad virtual int depth(GlyphIndex target = 0) const;\
\quad virtual Glyph* target(int depth, GlyphIndex target = 0) const;\
\quad virtual GlyphIndex index(int depth, GlyphIndex = 0) const;\
\quad virtual Handler* handler() const;\
\};%
%
\figurecaption{Hit class interface\label{hit}.}%
%
%-1.67999 0.240051 2
}%
%
 \ref{hit} shows the hit class operations.  A hit object may be constructed
with a point, a rectangle, or an event.  In the case of the event,
the event pointer coordinates are used to detect intersection and
glyphs can associate a handler with the pick result.

\quad Hit::event, Hit::left, Hit::bottom, Hit::right, Hit::top return
information about the specified hit area.  Hit::event returns nil
if the point or rectangle constructors were used.

\quad Hit::push\_transform, Hit::transform, and Hit::pop\_transform
modify the current intersection area for picking.  These operations
are just like the canvas operations with the same names except they
apply to the hit information instead of a canvas.

\quad Glyphs record information in a hit object with Hit::begin, Hit::target
and Hit::end.  Hit::target indicates that a glyph's output intersects
the hit region.  Hit::begin and Hit::end are used by composite glyphs
that should be on the hit list if and only if one of their components
calls Hit::target.  The parameters to Hit::begin and Hit::target have
the same meaning.  The depth is the level in the hit list where the  information
should be stored.  The glyph is the hit glyph.  The index is additional
information about the hit.  For a composite glyph, this is typically
the index of the hit child.  Hit::remove and Hit::retarget modify
the current hit information.

\quad The remaining hit operations return information about a pick.  The
result is a list of paths, each of which contains a list of glyphs
terminating with the glyphs that would draw through the pick region.  Hit::count
returns the number of paths.  Hit::depth returns the index of the
last glyph in a specified path.  The path corresponding to the top-most
glyph is in position zero.  Hit::target and Hit::index return the
information for a given path and depth.

\quad If a pick is done on a hit object constructed from an event,
and one or more glyphs find the event of interest, they will associate
a handler with the hit object.  Hit::handler returns the top-most,
deepest handler, or nil if there is none.%
%
\subsection{Composition}%
%
BreakType defines the choices for how a composite glyph might break
a group of glyphs in a layout.  The break may occur before a glyph
(pre\_break), in the glyph (in\_break), or after the glyph (post\_break).

\quad Glyph::compose on a glyph returns a new glyph that should be
used to replace the target glyph when the break occurs. For example,
discretionary white space in a document will turn into zero-size glue
if a line-break or page-break occurs on it. %
%
\subsection{Structure}%
%
Several operations are provided to manipulate the list of components
that make up a composite glyph.  Primitive glyphs ignore these operations,
while monoglyphs pass the operation through to their body.  A monoglyph
is therefore ``transparent'' with respect to structure, allowing one
to put a monoglyph around a composite and pass the result to another
object that manipulates the components of the composite.

\quad Glyph::append (prepend) adds a given glyph to the end (beginning)
of the component list.  Glyph::insert adds a given glyph at a specified
index in the list.  Glyph::remove removes the glyph at the specified
index.  Glyph::replace replaces the glyph at the specified index with
the given glyph.  Glyph::change notifies a glyph that its component
at the given index has changed, and therefore it might be necessary
to reallocate it.

\quad Glyph::count returns the number of glyphs in its component list.  Glyph::component
returns the glyph in its component list at the given index.  Glyph::allotment
returns the allocation information in the given dimension for the
glyph at the given index in its component list.%
%
\subsection{Requisitions}%
%
Glyphs define their geometric needs with a {\bf requisition}, which
specifies a {\bf requirement} in each dimension.  Figure%
%
\code{class Requisition \{\
public:\
\quad Requisition();\
\quad Requisition(const Requisition\&);\smallskip
\quad void penalty(int);\
\quad int penalty() const;\smallskip
\quad boolean equals(const Requisition\&, float epsilon) const;\smallskip
\quad void require(DimensionName, const Requirement\&);\
\quad const Requirement\& requirement(DimensionName) const;\
\quad Requirement\& requirement(DimensionName);\
\};\smallskip
class Requirement \{\
public:\
\quad Requirement();\
\quad Requirement(Coord natural);\
\quad Requirement(Coord natural, Coord stretch, Coord shrink, float);\
\quad Requirement(\
\quad \quad Coord natural\_lead, Coord max\_lead, Coord min\_lead,\
\quad \quad Coord natural\_trail, Coord max\_trail, Coord min\_trail\
\quad );\smallskip
\quad boolean equals(const Requirement\&, float epsilon) const;\
\quad boolean defined() const;\smallskip
\quad void natural(Coord);\
\quad Coord natural() const;\
\quad void stretch(Coord);\
\quad Coord stretch() const;\
\quad void shrink(Coord);\
\quad Coord shrink() const;\
\quad void alignment(float);\
\quad float alignment() const;\
\};%
%
\figurecaption{Requisition and Requirement classes\label{requisition}.
}%
%
%-1.68001 -3.60004 4
}%
%
 \ref{requisition} shows the requisition and requirement class interfaces.

\quad Composite glyphs typically use a layout object to arrange their
components in some manner such as a tile or overlay.  Layouts are
often dimension-independent; for example, there is no algorithmic
difference between left-to-right and top-to-bottom tiling. Requisitions
can therefore be specified and retrieved independently in each dimension.

\quad Requisition::Requisition creates a requisition with undefined
requirements.  Requisition::penalty is overloaded to set or get the
penalty associated with choosing a break at the position defined by
the requisition.  Requisition::require sets a requirement in a given
dimension.  Requisition::requirement returns the requirement for a
given dimension.

\quad A requirement consists of a natural size, stretchability, shrinkability,
and alignment.  The maximum size is the natural size plus the stretchability;
the minimum is the natural minus the shrinkability.  It is possible
to have negative minimum sizes.  The alignment is a fraction that
indicates the origin of the area.  An alignment of zero means the
origin is at the lower coordinate value; an alignment of one means
it is at the upper coordinate value.

\quad There are four constructors for requirement: with no parameters,
which makes the natural size undefined and the other fields zero;
with a single coordinate that defines the natural size and makes the
other fields zero; with explicit coordinates for the natural size,
stretchability, and shrinkability, and a float value for the alignment;
and with explicit coordinates for specifying the distances on each
side of the origin.

\quad Requirement::equals compares two requirements (the target object
and the argument) using a given tolerance for the individual coordinate
comparisons.  Requirement::defined returns whether the natural size
has been defined.  The overloaded functions natural, stretch, shrink,
and alignment set and get the respective values.%
%
\section{Allocations}%
%
The actual size a glyph is given is defined by an {\bf allocation},
which specifies an {\bf allotment} in each dimension.  Figure \ref{allot}
shows the allocation and allotment class interfaces.%
%
\code{class Allocation \{\
public:\
\quad Allocation();\
\quad boolean equals(const Allocation\&, float epsilon) const;\
\quad void allot(DimensionName, const Allotment\&);\
\quad Allotment\& allotment(DimensionName);\
\quad const Allotment\& allotment(DimensionName) const;\
\quad Coord x() const;\
\quad Coord y() const;\
\quad Coord left() const;\
\quad Coord right() const;\
\quad Coord bottom() const;\
\quad Coord top() const;\
\};\
\
class Allotment \{\
public:\
\quad Allotment();\
\quad Allotment(Coord origin, Coord span, float alignment);\
\quad boolean equals(const Allotment\&, float epsilon) const;\
\quad void origin(Coord);\
\quad void offset(Coord);\
\quad Coord origin() const;\
\quad void span(Coord);\
\quad Coord span() const;\
\quad void alignment(float);\
\quad float alignment() const;\
\quad Coord begin() const;\
\quad Coord end() const;\
\}; %
%
\figurecaption{Allocation and allotment class interfaces\label{allot}}%
%
%-0.960022 3.84009 6
}%
%
 An allotment specifies one dimension of an allocation with three
values: an origin, a span, and an alignment.  The origin is a position
within the allotment and the span is the size of the allotment.  The
alignment is a fraction specifying the position of the origin.  For
example,  if the origin is 1, span is 10, and alignment is 0.5, then
the allotment begins at -4 and ends at 6.

\quad The allocation constructor initializes each allotment to have
zero values.  Allocation::equals compares two allocations using a
tolerance for individual coordinate comparisions.  Allocation::allot
sets the allotment for a given dimension.  Allocation::allotment returns
the allotment for a specified dimension.

\quad Several operations are provided for convenience when accessing
allotments in the X and Y dimensions.  Allocation::x and Allocation::y
return the X and Y origins.  Allocation::left and Allocation::right
return the X dimension end-points, Allocation::bottom and Allocation::top
return the Y dimension end-points.

\quad The Allotment class also provides an equals operation for comparing
two allotments with a given tolerance.  Allotment::origin, Allotment::span,
and Allotment::alignment are overloaded names for setting and getting
the allotment values.  Allotment::offset adds to the current origin.

\quad Allotment::begin and Allotment::end return the end-points of
an allotment.  Allotment::begin is equivalent to the origin minus
the alignment times the span.  Allotment::end is equivalent to Allotment::begin
plus the span. %
%
\section{Primitive glyphs}%
%
Primitive glyphs do not contain component glyphs--they are leaf nodes
in a glyph instance graph.  Figure \ref{char} shows the Character,
Space, and Label class interfaces.%
%
\code{class Character : public Glyph \{\
public:\
\quad Character(long code, const Font*, const Color*);\
\};\
\
class Space : public Glyph \{\
public:\
\quad Space(unsigned int count, Coord each, const Font*, const Color*);\
\};\
\
class Label : public Glyph \{\
public:\
\quad Label(const char*, const Font*, const Color*);\
\quad Label(const String\&, const Font*, const Color*);\
\}; %
%
\figurecaption{Character, Space, and Label class interfaces\label{char}}%
%
%-1.92001 7.6799 7
}%
%
  A {\font{Times-Bold}character} glyph draws a single character using
the given font and color.  The character code is effectively an index
into the font information.

\quad A {\font{Times-Bold}space} represents character spaces.  Fonts
typically provide a single space character, but applications need
different sizes of spacing for minimum spacing between words and sentences.  Unlike
glue, a space object can be picked.  A {\font{Times-Bold}label} is
semantically equivalent to an LRBox containing the individual characters
in a string.

\quad %
%
\code{class Rule : public Glyph \{\
public:\
\quad Rule(DimensionName, const Color*, Coord thickness);\
\};\smallskip
class Stencil : public Glyph \{\
public:\
\quad Stencil(const Bitmap*, const Color*);\
\};\smallskip
class Image : public Glyph \{\
public:\
\quad Image(const Raster*);\
\};%
%
\figurecaption{Rule, Stencil, and Image class interfaces\label{rule}}%
%
%-0.959976 -403.32 7
}%
%
Figure \ref{rule} shows the Rule, Stencil, and Image class interfaces.  A
{\font{Times-Bold}rule} is a line that is parallel to a coordinate
axis and is useful for separating objects visually.  For convenience,
HRule and VRule subclasses are provided for specifying horizontal
and vertical lines, respectively.  A {\font{Times-Bold}stencil} draws
through a bitmap using the given color. A bitmap is logically an array
of bits that can be zero or one.  For elements that are one, the stencil
draws in the foreground color.  For elements that are zero, the stencil
does not draw.  An {\font{Times-Bold}image} draws a raster.  The natural
size and origin of a stencil (image) is defined by the dimensions
and bearings of the bitmap (raster).

\quad Figure \ref{glue} shows the interfaces to the classes that affect
composition.%
%
\code{class Discretionary : public Glyph \{\
public:\
\quad Discretionary(int penalty, Glyph*);\
\quad Discretionary(int penalty, Glyph* no, Glyph* pre, Glyph* in,
Glyph* post);\
\};\
\
class Glue : public Glyph \{\
public:\
\quad Glue(DimensionName, Coord natural);\
\quad Glue(\
\quad \quad DimensionName, Coord natural, Coord stretch, Coord shrink,\
\quad \quad float alignment = 0\
\quad );\
\quad Glue(const Requisition\&);\
\};\smallskip
class ShapeOf : public Glyph \{\
public:\
\quad ShapeOf(const Glyph*);\
\};%
%
\figurecaption{Primitive glyphs that specify composition information\label{glue}}%
%
%-0.959969 0 8
}%
%
  A {\font{Times-Bold}discretionary} can take on one of several appearances
depending on whether a break occurs on it.  A common use of a discretionary
is for white space in a line of text, where the white space becomes
zero-width glue if a break occurs on the discretionary.  The penalty
associated with a discretionary defines the relative cost of breaking.

\quad A {\font{Times-Bold}glue} object is blank space with explicit
stretchability and shrinkability in a single dimension.  For convenience,
HGlue and VGlue subclasses are provided for horizontal and vertical
glue, respectively.  A {\font{Times-Bold}shape-of} object has no appearance
but  the identical shape of another glyph.%
%
\section{Composite glyphs}%
%
A composite glyph contains one or more components.  Typically, a composite
glyph uses a {\bf layout} object to arrange its components in some
manner such as a tile or overlay.  A layout is not a glyph, but an
object that helps glyphs manage the requests and allocations of a
group of components.  Figure \ref{layout} shows the class interfaces
for layout and its sub classes.%
%
\code{class Layout \{\
public:\
\quad virtual void request(\
\quad \quad unsigned long count, const Requisition*, Requisition\&
result\
\quad );\
\quad virtual void allocate(\
\quad \quad const Allocation\& given, unsigned long count,\
\quad \quad const Requisition*, Allocation\& result\
\quad );\
protected:\
\quad Layout();\
\};\
\
class Align : public Layout \{\
public:\
\quad Align(DimensionName);\
\};\
\
class Superpose : public Layout \{\
public:\
\quad Superpose(Layout*, Layout*, Layout* = nil,\
\quad \quad Layout* = nil, Layout* = nil\
\quad );\
\};\
\
class Tile : public Layout \{\
\quad Tile(DimensionName);\
\};\
\
class TileReversed : public Layout \{\
public:\
\quad TileReversed(DimensionName);\
\}; %
%
\figurecaption{Layout classes\label{layout}}%
%
%-2.28882e-05 -103.68 9
}%
%
 Layout is an abstract class, so the constructor is only available
to subclasses.  Layout::request computes a total requisition given
a set of {\sf {\size{10}count}} requisitions for the individual components.  Layout::allocate
uses the given allocation and individual requisitions to compute the
individual allocations.

\quad An {\font{Times-Bold}align} object is a layout that aligns all
its components origins in a particular dimension.  A {\font{Times-Bold}superpose}
overlays components using two to five other layouts.  A {\font{Times-Bold}tile}
is a layout that arranges components side-by-side in a particular
dimension.  The components are arranged in increasing order; that
is, the first component starts at the lowest coordinate in the dimension.  For
example, Tile(Dimension\_X) tiles left-to-right.  TileReversed is
just like Tile but places components in decreasing order.  For example,
TileReversed(Dimension\_Y) tiles top-to-bottom. %
%
\subsection{Boxes}%
%
A {\font{Times-Bold}box} is a composite glyph that arranges its components
according to a given layout.  For convenience, subclasses are provided
for common layouts.  Figure \ref{box} shows the class interfaces for
box and its predefined subclasses.%
%
\code{class Box : public Glyph \{\
public:\
\quad Box(Layout*, unsigned int initial\_size);\
\quad Box(\
\quad \quad Layout*,\
\quad \quad Glyph* = nil, Glyph* = nil, Glyph* = nil, Glyph* = nil,
Glyph* = nil,\
\quad \quad Glyph* = nil, Glyph* = nil, Glyph* = nil, Glyph* = nil,
Glyph* = nil\
\quad );\
\};\
\
class LRBox : public Box \{\
public:\
\quad LRBox(unsigned int initial\_size);\
\quad LRBox(\
\quad \quad Glyph* = nil, Glyph* = nil, Glyph* = nil, Glyph* = nil,
Glyph* = nil,\
\quad \quad Glyph* = nil, Glyph* = nil, Glyph* = nil, Glyph* = nil,
Glyph* = nil\
\quad );\
\};\
\
class TBBox : public Box \{\
public:\
\quad TBBox(unsigned int initial\_size);\
\quad TBBox(\
\quad \quad Glyph* = nil, Glyph* = nil, Glyph* = nil, Glyph* = nil,
Glyph* = nil,\
\quad \quad Glyph* = nil, Glyph* = nil, Glyph* = nil, Glyph* = nil,
Glyph* = nil\
\quad );\
\};\
\
class Overlay : public Box \{\
public:\
\quad Overlay(\
\quad \quad Glyph* = nil, Glyph* = nil, Glyph* = nil, Glyph* = nil,
Glyph* = nil,\
\quad \quad Glyph* = nil, Glyph* = nil, Glyph* = nil, Glyph* = nil,
Glyph* = nil\
\quad );\
\}; %
%
\figurecaption{Box classes\label{box}}%
%
%-0.960014 -115.2 10
}%
%
  A box can be constructed either with a list of up to 10 glyph components,
or an {\sf {\size{10}initial\_size}} estimate on the number of components.  The
size is not a maximum, but can be used to avoid growing the list dynamically.  The
base class is given a specific layout to use.  LRBox uses a tile layout
in the X dimension to arrange its components left-to-right.  TBBox
uses a tile-reversed layout in the Y dimension to arrange its components
top-to-bottom.  Overlay uses a superpose layout to place its components
in the same position.  The components are ordered from back-to-front.
%
%
\subsection{Decks}%
%
A {\font{Times-Bold}deck} is a composite glyph where only one of the
components is visible at any time.  The natural size is the maximum
size of the natural sizes of its components.  A deck can be stretched
to be as large as its largest  fully-stretched component.  Figure
\ref{deck} shows the class interface for deck.%
%
\code{class Deck : public Glyph \{\
public:\
\quad Deck();\
\quad int card() const;\
\quad void flip\_to(int index);\
\};%
%
\figurecaption{Deck class interface\label{deck}}%
%


class Page : public Glyph \{\
public:\
\quad Page(Glyph* background);\
\quad Coord left() const, bottom() const, right() const, top() const;\
\quad Coord x() const, y() const;\
\quad void move(unsigned int index, Coord x, Coord y);\
\quad void location(unsigned int index, Coord\& x, Coord\& y);\
\quad void show(unsigned int index, Coord\& x, Coord\& y);\
\quad boolean showing(unsigned int index) const;\
\}; %
%
\figurecaption{Page class interface\label{page}}%
%
%-0.959976 -329.28 11
}%
%
  Deck::card returns the index of the component that is currently
visible (or -1 if no component is showing).  Deck::flip\_to makes
the component at the given index the visible one. %
%
\subsection{Pages}%
%
A {\font{Times-Bold}page} is a composite glyph that contains a background
and any number of foreground components.  The location of the components
is specified explicitly.  Components of a page are drawn when the
page is drawn, except for components that are explicitly ``hidden''
using Page::show(false). Figure \ref{page} shows the class interface
for page.  Page::left, Page::bottom, Page::right, and Page::top return
the respective coordinates of the page's canvas as defined by the
page's most recent allocation.  Page::x and Page::y return the origin
of the page.  Page::move allocates the component specified by the
given index with its origin at the given position.  Page::location
returns the current origin of the specified component.  Page::show
turns on or off the allocation and drawing of the specified component.  Page::showing
returns whether the specified component is currently showing. %
%
\section{MonoGlyphs}%
%
MonoGlyph is an abstract class for glyphs that contain a single glyph,
called its {\it body}.  The default behavior of monoglyphs is to pass
operations on to the body.  For example, the implementation of MonoGlyph::draw
simply calls draw on the body.  This feature is very useful because
it means that a monoglyph can affect one aspect of the body's behavior
without changing other aspects.  In particular, monoglyphs usually
do not change structure management.  Therefore, a monoglyph can be
\252wrapped\272 around a composite glyph and the result passed to
an object that modifies the structure of the composite without knowing
about the presence of the monoglyph.  For example, suppose  a prototype
menu is built and returned to a function that appends the items.  All
the function need assume is that the prototype is some glyph; it can
use Glyph::append to put in the items.  The arrangement of the items
will be defined by the aggregate and any additional decoration, such
as a 3D borderframe or shadow, can be wrapped around the aggregate
independently.

%
%
\code{class MonoGlyph : public Glyph \{\
protected:\
\quad MonoGlyph();\
public:\
\quad virtual void body(Glyph*);\
\quad virtual Glyph* body() const;\
\}; %
%
\figurecaption{MonoGlyph class interface\label{monoglyph}}%
%
%-4.57764e-05 -487.68 12
}%
%
\quad Figure \ref{monoglyph} shows the MonoGlyph base class interface.
The constructor is protected because MonoGlyph is an abstract class.  A
non-nil glyph specifies the initial body.  MonoGlyph::body is overloaded
to set and return the body. %
%
\subsection{Decoration}%
%
A common use of monoglyphs is to decorate a glyph.  Decoration could
also be implemented by putting the body and a glyph that draws the
decoration into an overlay.  However, an overlay is a composite glyph,
so it interprets structure operations as manipulating the components
of the overlay.  With this approach, one could not pass a decorated
glyph to another object that wants to change the structure of the
body.  It is therefore more convenient to decorate glyphs using a
monoglyph.

%
%
\code{class Background : public MonoGlyph \{\
public:\
\quad Background(Glyph*, const Color*);\
\};\smallskip
class Border : public MonoGlyph \{\
public:\
\quad Border(Glyph*, const Color*, Coord thickness);\
\}; %
%
\figurecaption{Background and Border class interfaces\label{background}}%
%
%-0.959839 1.91998 13
}%
%
\quad Figure \ref{background} shows the interfaces to the Background
and Border classes.  A {\bf background} glyph draws a solid color
under its body.  Since they are typically used near the top of an
instance graph, background glyphs are more efficient than having each
object draw its own background.  A {\bf border} draws a thick solid
rectangle around the edge of a glyph.  Borders do not request additional
space; they simply draw underneath the body.  To dedicate space to
a border, it is necessary to use a {\bf margin} glyph, which allocates
additional space around its body.  Figure \ref{margin}%
%
\code{class Margin : public MonoGlyph \{\
public:\
\quad Margin(Glyph* body, Coord all);\
\quad Margin(Glyph*, Coord hmargin, Coord vmargin);\
\quad Margin(Glyph*, Coord left, Coord right, Coord bottom, Coord
top);\
\quad Margin(\
\quad \quad Glyph*, Coord left, Coord left\_stretch, Coord left\_shrink,\
\quad \quad Coord right, Coord right\_stretch, Coord right\_shrink,\
\quad \quad Coord bottom, Coord bottom\_stretch, Coord bottom\_shrink,\
\quad \quad Coord top, Coord top\_stretch, Coord top\_shrink\
\quad );\
\};%
%
\figurecaption{Margin class interface\label{margin}}%
%
%-0.959976 -417.72 13
}%
%
 shows the Margin class interface.%
%
\code{class Shadow : public MonoGlyph \{\
public:\
\quad Shadow(Glyph*, Coord x\_offset, Coord y\_offset, const Color*);\
\}; %
%
\figurecaption{Shadow class interface\label{shadow}}%
%
%1.91994 -6.10352e-05 14
}%
%
  Margin glyphs do not draw in the space.  For convenience, HMargin,
VMargin, LMargin, RMargin, TMargin, and BMargin subclasses are provided
that create horizontal, vertical, left, right, top, and bottom margins,
respectively.

\quad A {\bf shadow} draws a half-filled area under its body.  Because
it does not cover the entire window, using a shadow as the root glyph
in a window implies that the window should not be double-buffered.  Figure
\ref{shadow} shows the Shadow class interface.

\quad An {\bf lr-marker} is a glyph that can mark a region of its
body.  The marking is done by painting a color under the area or a
color on top of the area (or both).  The region is a shape normally
associated with text selections.  The LRMarker constructor takes two
colors, either of which can be nil if the associated underlay or overlay
drawing is not desired.  LRMarker::mark paints the given region.  If
y1 and y2 are the same, then the mark region is a single rectangle.  Otherwise,
the region is defined as starting at (x1,y1) and filling a height
of h1 to (x1,right()), then filling (left(),y1+h1) to (right(),y2)
and filling a height of h2 from (left(),y2) to (x2,y2).  LRMarker::unmark
restores the area to its unmarked appearance.  An {\bf xy-marker}
is simliar to an lr-marker, but it only paints a rectangular area.  While
an lr-marker is most useful for selecting text, xy-markers are useful
for selecting an item in a list or table.  Figure \ref{markers} shows
the LRMarker and XYMarker class interfaces.%
%
\code{class LRMarker : public MonoGlyph \{\
public:\
\quad LRMarker(Glyph*, Color* overlay, Color* underlay);\
\quad void mark(\
\quad \quad Coord left, Coord right, Coord x1, Coord y1,\
\quad \quad Coord h1, Coord x2, Coord y2, Coord h2\
\quad );\
\quad void unmark();\
\};\
\
class XYMarker : public MonoGlyph \{\
public:\
\quad XYMarker(Glyph*, Color* overlay, Color* underlay);\
\quad void mark(Coord left, Coord bottom, Coord right, Coord top);\
\quad void unmark();\
\}; %
%
\figurecaption{LRMarker and XYMarker class interfaces\label{markers}}%
%
%0.95993 -349.44 14
}%
%


\quad A {\bf transform-setter} is a glyph that contains a transformer
that it uses to change the canvas coordinate transformation matrix
during allocation, drawing, and picking.  The new matrix is the old
matrix multiplied by the transform-setter's matrix.  The natural size
of a transform-setter is the transformed natural size of its body.  A
transform-setter  does not decorate its body in the same sense as
the other glyphs described here, but it does modify the appearance
of its body.  Figure \ref{tformsetter} shows the TransformSetter class
interface.%
%
\code{class TransformSetter : public MonoGlyph \{\
public:\
\quad TransformSetter(Glyph*, const Transformer\&);\
\}; %
%
\figurecaption{TransformSetter class interface\label{tformsetter}}%
%
%-4.57764e-05 -6.10352e-05 15
}%
%
%
%
\subsection{Adjusting geometry}%
%
Figure \ref{center} shows the MonoGlyph subclasses that modify the
geometry of the body.  A {\bf center} glyph aligns its body within
an allocated area.  An alignment in a dimension is specified by a
floating point value, indicating the fraction of the total area where
the center of the component should be positioned.  Centering can be
performed on both the X and Y dimensions or on a specific dimension.  For
convenience, HCenter and VCenter subclasses are provided that center
horizontally and vertically, respectively.  The term ``center'' is
actually somewhat misleading because only an alignment of 0.5 actually
centers the body--a horizontal alignment of 1.0 will right adjust
it.  A center only changes the alignment of its body, it does not
set the position directly.  Therefore, if a center glyph is inside
a glyph that does not pay attention to alignments, the result will
not be centered as expected.  In particular, a top-level center glyph
will not have any effect because a window does not use alignments
to position its root glyph.

\quad A {\bf fixed-span} glyph controls the shape and allocation of
its body in one dimension.  FixedSpan::request simply replies with
its specified size ignoring its body.  Similarly, FixedSpan::allocate
ignores its allocation and passes the body its specified size.  A
fixed-span is ideal for use around objects that need a default size,
but do not wish to specify one themselves.  For example, a vertical
scrollbar needs a reasonable horizontal size, but would rather not
define one itself.  By using fixed-spans, other classes need not provide
optional constructors that specify sizes.%
%
\code{class Center : public Monoglyph \{\
public:\
\quad Center(Glyph*, DimensionName, float align = 0.5);\
\quad Center(Glyph*, float xalign = 0.5, float yalign = 0.5);\
\};\
\
class FixedSpan : public MonoGlyph \{\
public:\
\quad FixedSpan(Glyph*, DimensionName, Coord span);\
\}; %
%
\figurecaption{Center and FixedSpan class interfaces\label{center}}%
%
%4.57764e-05 -431.04 15
}%
%
%
%
\subsection{Compositions}%
%
A composition is a glyph that uses a {\bf compositor} to determine
suitable breaks between groups of its components.  Figure \ref{composition}
shows the class interfaces for the composition and its subclasses.  The
list of components is broken into sublists that are put into separate
composite glyphs and then inserted into the body.  The LRComposition
subclass builds an LRBox for each sublist, while the TBComposition
subclass builds a TBBox.

\quad Compositions can be used to break paragraphs into lines, lines
into columns, or columns into pages.  A document editor might create
an lr-composition for characters that puts the resulting lr-boxes
for lines into a tb-composition, which in turn puts the tb-boxes for
columns into an lr-composition, which puts the resulting lr-boxes
for pages into a deck.

\quad Compositions also can be used just as easily for arranging buttons
in a box, where one wants the buttons to ``wrap-around'' if there
are too many to fit horizontally.  The code to do this could look
as follows:

{\sf {\small \
\quad \quad \quad LRComposition* c = new LRComposition(\
\quad \quad \quad \quad new TBBox, new SimpleCompositor, /* no separator
*/ nil, /* width */ 4*72.0\
\quad \quad \quad );\
\quad \quad \quad Discretionary* ok = new Discretionary(0, nil, nil,
nil, nil);\
\quad \quad \quad for (unsigned int i = 0; i < nbuttons; i++) \{\
\quad \quad \quad \quad c->append(button[i]);\
\quad \quad \quad \quad c->append(ok);\
\quad \quad \quad \}\
\quad \quad \quad c->repair();\
 }}

\quad The composition constructor takes a body in which to insert
sublists, a compositor to determine where to break, a separator to
be inserted at each break (unless it is nil), the dimension to use,
the width in which the sublists must fit, and optionally the initial
size of the list of components.  The initial size is not a maximum,
but the list by default starts at a small size and is dynamically
reallocated as needed.  For large lists, it can be more efficient
to specify an estimate of the list size.  Composition::repair updates
the composition to reflect changes to its structure.  Composition::item
returns the index of the sublist (in other words, the component of
the body) containing the component specified by the given index.  For
example, this function could be used to return the line that contains
a particular character.  Composition::beginning\_of returns the index
of the component that starts the sublist specified by the given item.  For
example, this function could be used to return the character that
starts a particular line.  Composition::end\_of is like beginning\_of
except it returns the end of the sublist.  Composition::margin causes
space to be left at the beginning and end of the specified item in
the body.  For example, this function could be used to put margins
on a line of text.%
%
\code{class Composition : public MonoGlyph \{\
public:\
\quad virtual void repair();\
\quad virtual GlyphIndex item(GlyphIndex);\
\quad virtual GlyphIndex beginning\_of(GlyphIndex);\
\quad virtual GlyphIndex end\_of(GlyphIndex);\
\quad virtual void margin(GlyphIndex, Coord begin, Coord end);\
\quad virtual void view(GlyphIndex first, GlyphIndex last);\
protected:\
\quad Composition(\
\quad \quad Glyph*, Compositor*, Glyph* separator, DimensionName,\
\quad \quad Coord width, GlyphIndex size\
\quad );\
\};\
\
class LRComposition : public Composition \{\
public:\
\quad LRComposition(\
\quad \quad Glyph*, Compositor*, Glyph* sep, Coord, GlyphIndex = 10\
\quad );\
\};\
\
class TBComposition : public Composition \{\
public:\
\quad TBComposition(\
\quad \quad Glyph*, Compositor*, Glyph* sep, Coord, GlyphIndex = 10\
\quad );\
\}; %
%
\figurecaption{Composition classes\label{composition}}%
%
 %-6.10352e-05 -15.3601 17
}%
%
 Composition::view guarantees that breaks are computed for the components
between indices {\it first} and {\it last} inclusively.  By restricting
the viewing area, this operation can eliminate the computation of
breaks for components that are not visible.

\quad A compositor computes the breaks based on assessing the penalty
for a possible breaks.  Three subclasses are provided that use different
levels of sophistication in determining breaks.  An {\bf array-compositor}
positions breaks every N elements, where N is specified in the constructor.  A
{\bf simple-compositor} finds a simple set of breaks quickly.  It  is
analogous to a line-at-a-time text formatter.  A {\font{Times-Bold}TeX-compositor}
finds breaks using Knuth's TeX algorithm.

\quad Figure \ref{compositor} shows the interfaces to the compositor
classes.  Compositor::compose uses the natural, stretch, shrink, penalty,
and span information for each component as input parameters.  The
return value is the number of breaks found.  The {\sf {\size{10}breaks}}
array contains the positions of the breaks; that is, {\sf {\size{10}break[i]}}
is the index of the component where the {\it i}th break occurs.%
%
\code{class Compositor \{\
public:\
\quad virtual int compose(\
\quad \quad Coord* natural, Coord* stretch, Coord* shrink,\
\quad \quad int* penalties, int component\_count,\
\quad \quad Coord* spans, int span\_count,\
\quad \quad int* breaks, int break\_count\
\quad );\
\};\
\
class ArrayCompositor : public Compositor \{\
public:\
\quad ArrayCompositor(int N);\
\};\
\
class SimpleCompositor : public Compositor \{\
public:\
\quad SimpleCompositor();\
\};\
\
class TeXCompositor : public Compositor \{\
public:\
\quad \quad TeXCompositor(int penalty);\
\}; %
%
\figurecaption{Compositor classes\label{compositor}}%
%
%0.959976 -46.0802 18
}%
%
%
%
\subsection{Patches}%
%
A patch stores its canvas and allocation for subsequent use to update
its body.  A patch is useful for objects that need to be redrawn independently,
such as those that depend on some external data.  Typically, a patch
appears in the middle of a glyph instance graph, where a change would
be too expensive to redraw the entire graph.

\quad Figure \ref{patch} shows the Patch class interface.%
%
\code{class Patch : public MonoGlyph \{\
public:\
\quad Patch(Glyph*);\
\quad virtual Canvas* canvas(); const\
\quad virtual const Allocation\& allocation(); const\
\quad virtual void reallocate();\
\quad virtual void redraw(); const\
\quad virtual boolean repick(int depth, Hit\&);\
\}; %
%
\figurecaption{Patch class interface\label{patch}}%
%
%-1.52588e-05 -15.36 19
}%
%
  Patch::canvas and Patch::allocation return the canvas and allocation
most recently passed to Patch::draw.  Patch::reallocate calls allocate
on the body using the current allocation, usually because the body
has changed in some way and will allocate its itself differently.  Patch::redraw
calls draw on the body using the current allocation.  Patch::repick
returns the result of calling pick on the body with the current canvas
and allocation.%
%
\section{Example}%
%
Below is a simple application that displays a raster in a window.  The
application defines a monoglyph subclass, called ScaleToFit, that
scales the image to make it fit in the window.  Thus, if the user
resizes the window then the image will automatically be rescaled to
fill the entire window.  The application assumes the file is in an
image format called TIFF, for which InterViews provides a  function
to load into a raster.

\quad The ScaleToFit constructor simply passes the body to the monoglyph
constructor.  ScaleToFit reimplements three glyph operations:  request,
allocate, and draw.  A more general ScaleToFit should also reimplement
pick, but in this application we are simply displaying the image and
do not handle input.

\quad ScaleToFit::request creates an allocation for the body that
matches its requisition.  ScaleToFit::allocate computes a transformation
matrix for scaling between its allocation and the requisition of its
body (as represented by the allocation that ScaleToFit::request computed).  ScaleToFit::allocate
then transforms the canvas appropriately and calls allocate on its
body.  ScaleToFit::draw simply transforms the canvas and calls draw
on the body.\newpage
\medskip
\quad \#include <InterViews/display.h>\
\quad \#include <InterViews/image.h>\
\quad \#include <InterViews/monoglyph.h>\
\quad \#include <InterViews/raster.h>\
\quad \#include <InterViews/tiff.h>\
\quad \#include <InterViews/session.h>\
\quad \#include <InterViews/style.h>\
\quad \#include <InterViews/transformer.h>\
\quad \#include <InterViews/window.h>\
\quad \#include <stdio.h>\
\quad \#include <stdlib.h>\smallskip
\quad class ScaleToFit : public MonoGlyph \{\
\quad public:\
\quad \quad ScaleToFit(Glyph*);\
\quad \quad virtual void request(Requisition\&) const;\
\quad \quad virtual void allocate(Canvas*, const Allocation\&, Extension\&);\
\quad \quad virtual void draw(Canvas*, const Allocation\&) const;\
\quad private:\
\quad \quad Allocation allocation\_;\
\quad \quad Transformer matrix\_;\
\quad \};\smallskip
\quad ScaleToFit::ScaleToFit(Glyph* g) : MonoGlyph(g) \{ \}\smallskip
\quad void ScaleToFit::request(Requisition\& r) const \{\
\quad \quad MonoGlyph::request(r);\
\quad \quad ScaleToFit* s = (ScaleToFit*)this; \quad \
\quad \quad Requirement\& rx = r.requirement(Dimension\_X);\
\quad \quad rx.stretch(fil);\
\quad \quad rx.shrink(fil);\
\quad \quad Coord xsize = rx.natural();\
\quad \quad float xalign = rx.alignment();\
\quad \quad Allotment ax(xalign * xsize, xsize, xalign);\
\quad \quad s->allocation\_.allot(Dimension\_X, ax);\smallskip
\quad \quad Requirement\& ry = r.requirement(Dimension\_Y);\
\quad \quad ry.stretch(fil);\
\quad \quad ry.shrink(fil);\
\quad \quad Coord ysize = ry.natural();\
\quad \quad float yalign = ry.alignment();\
\quad \quad Allotment ay(yalign * ysize, ysize, yalign);\
\quad \quad s->allocation\_.allot(Dimension\_Y, ay);\
\quad \}\smallskip
\pagebreak
\smallskip
\quad void ScaleToFit::allocate(Canvas* c, const Allocation\& a, Extension\&
ext) \{\
\quad \quad matrix\_ = Transformer();\
\quad \quad matrix\_.scale(\
\quad \quad \quad a.allotment(Dimension\_X).span() /\
\quad \quad \quad \quad allocation\_.allotment(Dimension\_X).span(),\
\quad \quad \quad a.allotment(Dimension\_Y).span() /\
\quad \quad \quad \quad allocation\_.allotment(Dimension\_Y).span()\
\quad \quad );\
\quad \quad c->push\_transform();\
\quad \quad c->transformation(matrix\_);\
\quad \quad MonoGlyph::allocate(c, allocation\_, ext);\
\quad \quad c->pop\_transform();\
\quad \}\smallskip
\quad void ScaleToFit::draw(Canvas* c, const Allocation\&) const \{\
\quad \quad c->push\_transform();\
\quad \quad c->transform(matrix\_);\
\quad \quad MonoGlyph::draw(c, allocation\_);\
\quad \quad c->pop\_transform();\
\quad \}\smallskip
\quad int main(int argc, char** argv) \{\
\quad \quad Session* session = new Session("Ipaste", argc, argv);\
\quad \quad if (argc == 1) \{\
\quad \quad \quad fprintf(stderr, "Usage: \%s <file>\backslash n",
argv[0]);\
\quad \quad \quad exit(1);\
\quad \quad \}\smallskip
\quad \quad Raster* rast = TIFFRaster::load(argv[1]);\
\quad \quad if (rast == nil) \{\
\quad \quad \quad fprintf(stderr, "\%s: open tiff image \%s failed\backslash
n", argv[0], argv[1]);\
\quad \quad \quad exit(1);\
\quad \quad \}\smallskip
\quad \quad Style* style = session->default\_display()->style();\
\quad \quad session->run\_window(\
\quad \quad \quad new ApplicationWindow(new ScaleToFit(new Image(rast)))\
\quad \quad );\
\quad \}

%
\end{document}
